CREATE DATABASE  IF NOT EXISTS `tests` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */;
USE `tests`;
-- MySQL dump 10.13  Distrib 8.0.13, for Win64 (x86_64)
--
-- Host: localhost    Database: tests
-- ------------------------------------------------------
-- Server version	8.0.13

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
 SET NAMES utf8 ;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `тест №4 ооп с.`
--

DROP TABLE IF EXISTS `тест №4 ооп с.`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `тест №4 ооп с.` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `question` longtext NOT NULL,
  `answers` longtext NOT NULL,
  `good_answer` longtext NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `тест №4 ооп с.`
--

LOCK TABLES `тест №4 ооп с.` WRITE;
/*!40000 ALTER TABLE `тест №4 ооп с.` DISABLE KEYS */;
INSERT INTO `тест №4 ооп с.` VALUES (1,'Класс - это?','любой тип данных, определяемый пользователем;тип данных, определяемый пользователем и сочетающий в себе данные и функции их обработки;структура, для которой в программе имеются функции работы с нею;Нет правильного ответа¯','1'),(2,'Членами класса могут быть?','как переменные, так и функции, могут быть объявлены как private и как publi;только переменные, объявленные как private;только функции, объявленные как private;только переменные и функции, объявленные как private¯','0'),(3,'Что называется конструктором?','метод, имя которого совпадает с именем класса и который вызывается автоматически при создании объекта класса;метод, имя которого совпадает с именем класса и который вызывается автоматически при объявлении класса(до создания объекта класса);метод, имя которого необязательно совпадает с именем класса и который вызывается при создании объекта класса;метод, имя которого совпадает с именем класса и который необходимо явно вызывать из головной программы при объявлении объекта класса¯','0'),(4,'Объект - это?','переменная, содержащая указатель на класс;экземпляр класса;класс, который содержит в себе данные и методы их обработки;Нет правильного ответа¯','1'),(5,'Отметьте правильное утверждение','конструкторы класса не наследуются;конструкторов класса может быть несколько, их синтаксис определяется программистом;конструкторов класса может быть несколько, но их синтаксис  не должен подчиняться правилам перегрузки функций;конструктор возвращает указатель на объект¯','0'),(6,'Что называется деструктором?','метод, который уничтожает объект;метод, который удаляет объект;метод, который освобождает память, занимаемую объектом;системная функция, которая освобождает память, занимаемую объектом¯','2'),(7,'Выберите правильное утверждение','у конструктора могут быть параметры;конструктор наследуется, но должен быть перегружен;конструктор должен явно вызываться всегда перед объявлением объекта;объявление каждого класса должно содержать свой конструктор¯','0'),(8,'Выберите правильное утверждение','деструктор - это метод класса, применяемый для удаления объекта;деструктор - это метод класса, применяемый для освобождения памяти, занимаемой объектом;деструктор - это отдельная функция головной программы, применяемая для освобождения памяти, занимаемой объектом;деструктор наследуется, но должен быть перегружен¯','1'),(9,'Что называется наследованием?','это механизм, посредством которого производный класс получает элементы родительского и может дополнять либо изменять их свойства и методы;это механизм переопределения методов базового класса;это механизм, посредством которого производный класс получает все поля базового класса;это механизм, посредством которого производный класс получает элементы родительского, может их дополнить, но не может переопределить¯','0'),(10,'Выберите правильное объявление производного класса','class MoreDetails:: Details;class MoreDetails : public class Details;class MoreDetails : public Details;class MoreDetails : class(Details)¯','2'),(11,'Выберите правильное утверждение','если элементы класса объявлены как private, то они доступны только наследникам класса, но не внешним функциям;если элементы класса объявлены как private, то они недоступны ни наследникам класса, ни внешним функциям;если элементы объявлены как public, то они доступны наследникам класса, но не внешним функциям;если элементы объявлены как public, то они не доступны и наследникам класса, и внешним функциям¯','1'),(12,'Возможность и способ обращения производного класса к элементам базового определяется?','ключами доступа: private, public, protected в теле производного класса;только ключом доступа protected в заголовке объявления производного класса;ключами доступа: private, public, protected в заголовке объявления производного класса;ключами доступа: private, public, protected в теле базового класса¯','2'),(13,'Выберите правильное соответствие между спецификатором базового класса, ключом доступа в объявлении производного класса и правами доступа прозводного класса к элементам базового','ключ доступа - public в базовом классе: private права доступа в производном классе - protected;ключ доступа - любой в базовом классе: private права доступа в производном классе - нет прав;ключ доступа - private в базовом классе: public права доступа в производном классе - public;ключ доступа – не любой в базовом классе: public права доступа в производном классе – не такие же, как ключ доступа¯','1'),(14,'Дружественная функция - это?','функция другого класса, среди аргументов которой есть элементы данного класса;функция, объявленная в классе с атрибутом friend, но не являющаяся членом класса;функция, являющаяся членом класса и объявленная с атрибутом friend;функция, которая в другом классе объявлена как дружественная данному¯','1'),(15,'Выберите правильное утверждение','одна функция может быть дружественной нескольким классам;дружественная функция не может быть обычной функцией, а только методом другого класса;дружественная функция объявляется внутри класса, к элементам которого ей не нужен доступ;дружественная функция не может быть методом другого класса¯','0'),(16,'Шаблон функции - это?','определение функции, в которой типу обрабатываемых данных присвоено условное обозначение;прототип функции, в котором вместо имен параметров указан условный тип;определение функции, в котором указаны возможные варианты типов обрабатываемых параметров;определение функции, в котором в прототипе указан условный тип, а в определении указаны варианты типов обрабатываемых параметров¯','0'),(17,'Выберите правильное утверждение','по умолчанию члены класса имеют атрибут private;по умолчанию члены класса имеют атрибут public;члены класса имеют доступ только к элементам public;элементы класса с атрибутом private доступны не только членам класса¯','0'),(18,'Переопределение операций имеет вид','имя_класса, ключевое слово operation, символ операции;имя_класса, ключевое слово operator, символ операции, в круглых скобках могут быть указаны аргументы;имя_класса, ключевое слово operator, список аргументов;имя_класса, два двоеточия, ключевое слово operator, символ операции¯','1'),(19,'Для доступа к элементам объекта используются?','при обращении через имя объекта – точка, при обращении через указатель – операция «->»;при обращении через имя объекта – два двоеточия, при обращении через указатель – операция «точка»;при обращении через имя объекта – точка, при обращении через указатель – два двоеточия;при обращении через имя объекта – два двоеточия, при обращении через указатель – операция «->»¯','0'),(20,'Полиморфизм – это?','средство, позволяющее использовать одно имя для обозначения действий, общих для родственных классов;средство, позволяющее в одном классе использовать методы с одинаковыми именами;средство, позволяющее перегружать функции для работы с разными типами или разным количеством аргументов.;средство, позволяющее в одном классе использовать методы с разными именами для выполнения одинаковых действий¯','0');
/*!40000 ALTER TABLE `тест №4 ооп с.` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-03-22 22:52:26
